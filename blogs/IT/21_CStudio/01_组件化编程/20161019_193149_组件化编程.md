# 组件化编程

- 什么是组件化 
- 组合和继承
- 组件化编程的优势 
- 组件化实现方式
- 组件化的劣势
- 为什么要进行组件化

## 一、什么是组件化
**组件化**的定义每个人都有一个属于自己的理解，并不能说一定代表什么。**就我个人而言，就是把一个整体的东西分模块，每个模块相对完整独立，互不干涉，这样的模块就是组件。而进行这个划分模块的过程就是组件化**。

## 二、组合和继承
随着面向对象编程的普及，继承式开发是每个程序员百分之百会用到的编程方式。它讲究的是将具体的事物进行抽象，把事物本身的特点和属性信息封装成“类”，并通过类来实例对象的编程手段。通常是以一个个体作为封装的对象。对象可以通过继承简单的对象进行拓展，实现更加强大的功能。

**组合是将事物看成是由零散的零件凑在一起合成的，是把事物的功能单独进行封装，然后将各个独立的简单功能聚合到一起，组成一个整体。**

关于组合和继承的优劣之争由来已久，确实很难说明组合式编程和继承式编程哪个更好。

## 三、组件化编程的优势
既然要说优势，那么难免要拿继承式开发进行比较。先来看看继承带来的负面影响。

在早期，通过类继承的方式，程序员可以将具有相同功能的事物进行抽象封装，然后通过继承来泛化各种各样的子类，这些子类同样具有父类（基类）的所有功能特性，父类的代码得到了最高的复用。但是随着计算机领域的快速发展，软件系统的逐步庞大，继承链变得越来越长，一个强大的类，其功能可能是通过几十次继承操作而来的。

而且其中还伴随着各种各样的引用关联关系，整个系统的类图错综复杂，很难一目了然的了解系统的组成。而且有的时候只是为了要复用一个类的部分代码，程序员还是需要将那整个类都继承过来，造成了继承式冗余，虽然有接口（Interface）、协议（protocol）和各种设计模式来避免，但是很多程序员开发过程中难免“偷懒”。

组合式编程是将单一的功能进行封装，每个功能是一个组件。由于其实现的逻辑相对单一，所以每个组件的代码相对而言并不会太复杂，同时组件与组件之间要求互不影响（内敛、松耦）。而对象由多个组件组合而成，所以对象和组件之间只有引用关系，消除了冗长的继承链。对象需要具备某个功能，只需要挂载对应的组件即可，这样不会显得臃肿，代码的复用性也比较高，可拓展性强。

## 四、组件化实现方式
组件化的实现方式是将事物抽象为一个单纯的“实体”（Entity），事物所具备的功能和特征属性封装到“组件”（Component）中。这样的框架我们称之为“实体-组件系统”（ECS）。

### 4.1、核心概念
**【实体】**：在ECS中，实体是组件化编程的核心之一。它的作用是表示某个对象可以理解成继承式开发中的类，但是它只是一个非常单纯的类，或者说只是一个类似“Object”一样的非常原始、功能单一的类。因为它只负责**管理组件**，没有像继承式编程中那些具体类那么明显的特征。

**【组件】**：组件是组件化编程的另一个核心。它的使命是对实体进扩展，让单纯的实体拥有各种各样的功能，我们可以抽象的认为**“实体就是由多个组件组合而成”**。

### 4.2、游戏对象（GameObject）
GameObject就是一个实体对象，它需要包含一个“components”的集合属性，用于存储当前实体对象上挂载的组件对象。另外还需要提供两个最重要的API，“addComponent”和“removeComponent”进行组件的添加和移除操作。

```lua

-- 游戏对象类
local M = class("GameObject")

-- 构造方法
function M:ctor(params)
	-- 组件集合
	self.components 	= {}
end

-- 添加组件(参数是组件的类型，用于实例化组件)
function M:addComponent(componentClass)
	-- 获取组件的类名
	local name	= componentClass.__cname
	
	-- 判断组件是否存在
	if self.components[name] then 
		return error("已经存在类型为‘".. name .."’的组件，不能重复添加。")
	end
	
	-- 实例化组件对象
	local component 	= componentClass.new({gameObject = self})
	-- 缓存组件
	self.components[name] 	= component
end 

-- 移除组件（参数是组件的类型，用于查找组件对象）
function M:removeComponent(componentClass)
	-- 获取组件的类名
	local name	= componentClass.__cname
	-- 获取组件对象
	local component 	= self.components[name]
	
	if component then 
		-- 销毁组件
		component:onDestruct()
	end
	
	-- 移除缓存
	self.components[name] = nil
end

return M

```

这样，一个简单的游戏对象实体类就创建完毕了，虽然还不是很完善，但是基本功能算是实现了。

### 4.3、组件（Component）
接下来分析下Component组件类，组件主要是为了控制游戏对象，实现游戏逻辑的，所以它必须包含一个名为“gameObject”的属性，用于指向组件挂载的游戏对象实例。同时，它还应该具备一个名为“__cname”的属性，用于保存当前组件类的类名（这一步在quick-cocos2d-x的class()中已经实现了，我们可以不用管）。 

除此之外，参考上面GameObject类的实现，会发现在移除组件的时候调用了组件对象的“onDestruct”方法，所以组件需要提供一个这样的析构方法。

``` lua

-- 组件类
local M = class("Component")

-- 构造方法
function M:ctor(params)
	assert(type(params) == "table", "实例化组件的参数必须是一个table。")
	assert(params.gameObject and params.gameObject.__cname == "GameObject", "组件必须通过GameObject进行实例化。")
	
	-- 关联游戏对象
	self.gameObject 	= params.gameObject
end

-- 析构方法
function M:onDestruct()
	-- 解除引用
	self.gameObject = nil 
end


return M 

```

一个简单的组件类也基本实现了。接下来要做的就是实例化GameObject，然后调用实例对象的addComponent进行组件的创建，这样就完成了整个实体组件系统的初步框架。

## 五、组件化的劣势
由于组件是在GameObject上进行管理的，所以某些实现需要遍历操作，对性能有一定的影响。但是好在一个游戏对象上挂载的组件不会很多，主要是同一时刻有过多的游戏对象需要遍历触发组件的生命周期。（这在后面的博文中会陆续提到）

## 六、为什么要进行组件化
组件化除了它显而易见的高度模块化和框架结构简单之外，另外一个重要的因素是，它彻底的将渲染显示（UI）和逻辑处理（功能实现）进行了剥离。在游戏开发过程中，把UI彻底剥离，是实现游戏场景编辑器的前提之一，游戏场景的编辑器只要进行简单的场景可视化布局操作就好了，不应该掺杂复杂的逻辑实现，组件化很好的做到了这一点。